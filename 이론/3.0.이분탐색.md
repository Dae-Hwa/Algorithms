# 이분탐색(Binary Search)

Binary = 2진법, 두 부분으로 나뉜 => 두 부분으로 나눠서 찾는다~

오름차순으로 정렬돼있다 가정하고, 반으로 쪼개면서 가까운 쪽으로 이동해서 다시 반으로 쪼개는걸 반복한다.

시간복잡도는  log(n). 반씩 줄여나가니까.. 10만개를 16번 만에 찾을 수 있다 wow~

## 예시

기본 구현으로 범위와 현재 위치를 잡는다.

배열 A가 있을때,
L := A를 탐색할 왼쪽 끝 인덱스
R := A를 탐색할 오른쪽 끝 인덱스
M = 탐색할 A의 위치
Result = 탐색완료한 A의 위치(탐색이 끝난 뒤 최종 값으로 판단)

예시 - 주어진 배열에서 x에 가장 근접하게 작은 원소. x = 63

A[10, 11, 18, 19, 38, 58, 72, 87, 92]
 [ 0,  1,  2,  3,  4,  5,  6,  7,  8]

1. L=0, R=8, M = (L+R)/2 = 4, result = 4
  - A[4] 가 x 보다 작다 => 오른쪽으로 간다
  - A[4]는 이미 봤으니까 L = M + 1이 되면 된다
2. L=5, R=8, M = (L+R)/2 ~= 6 result = 6
  - A[6] 은 x보다 크니 R값 갱신 (M - 1)
3. L=5, R=5 result = 5
  - A[5] 는 x보다 크니 L값 갱신 (M + 1)
4. L=6, R=5
  - L과 R이 만날 수 없으니 탐색 종료. result 5로 최종 판단

## 주의점

1. 정렬을 하지 않은 경우
2. 부등호 잘못 쓰는 경우
3. 잘못된 L, R 범위 및 Result 초기값 설정
