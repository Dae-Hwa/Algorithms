# linked list cycle

https://leetcode.com/problems/linked-list-cycle/

사이클 존재 유무 확인

## 풀이

### 1차시(실패)

Set에 Node의 val을 넣고 돌렸다.

### 2차시

Node가 같은 값을 포함할 수 있다는 것을 알게 되었다. 이건 조건이 좀... equals가 없으니 당연한거긴 하지만 설명이 좀 부족한 느낌이다.

어쨌든 Set에 인스턴스 자체를 넣어줬다.

### 3차시

풀이를 보니 해쉬 외에 플로이드 순환 찾기 알고리즘을 사용할 수 있다고 한다.

원리는 다음과 같다.

1. 포인터 A는 1칸씩 움직인다.
2. 포인터 B는 2칸씩 움직인다.
3. 결과 판단
    1. 언젠가 포인터 A와 B가 만나게 되는데 그러면 사이클이 있는 것이다.
    2. 만약 루프가 종료되면 사이클이 없는 것이다.

처음에는 이해가 잘 안갔는데 조금 생각해보니 이해가 간다.

논리적으로 루프가 종료되었다는 것은 사이클이 없는 것이다. 반면 루프가 종료되지 않으면 사이클이 계속 될 수 밖에 없다.

그러면 이 때, 포인터 A는 한 칸씩 가기 때문에 포인터 B는 언젠가 B를 따라잡게 된다. 그 순간이 온다면 사이클이 있는 것임을 확신할 수 있다.

추가로 사이클의 시작점을 찾으려면 위의 과정에서 A와 B가 만난 지점과 시작지점(head)에서 출발하여 한 칸씩 움직인 뒤 만나는 곳을 찾으면 된다.

원리는 사이클을 찾는 과정에서 만나는 곳을 수식으로 풀이하면 다음과 같이 된다.

```text
|-----┬--|--┐
0     M  K  |
S     └──l──┘ <-사이클
```

- 시작점 `S`에서 출발하여 사이클이 시작되는 곳을 `M` 라고 한다.
- 포인터 A 와 B 가 만난 지점을 `K` 라고 한다. 사이클의 길이는 `l` 이라고 한다.

한 칸씩 움직인 포인터 A가 움직인 거리는 다음과 같다.
`A = M + i*l + K`
> 이 때 i는 임의의 정수로, 사이클의 길이 만큼 i번 움직였다는 의미다.

포인터 B는 두 칸씩 움직였기 때문에 A가 수행한 작업을 두 번 한것과 같다.
`B = 2 * (M + i*l + K)`

이 때, A와 B는 모두 같은 지점에서 종료한다. 따라서

`M + i*l + K = 2 * (M + i*l + K)`

정리하면 다음과 같다.

`M + i*l + K = 0`
-> `M + K = -i*l`

만약 `S`에서 출발하여 `M`에서 만나려면, `K` 에서 `M` 만큼 움직였을때 사이클의 시작지점인 `M`에 도착해야 한다.

따라서, 우리가 확인하고자 하는 것은 `M`과 `l - K`가 같냐이다.

`M = l - K`

-> `M + K = l`

위에서 정리했던 식과 비교해보자.

```text
M + K = -i*l
M + K = l
```

결과적으로 `-i * l = l` 이 성립하느냐인데, 성립한다.

논리적으로 생각해봤을때, `i`는 사이클을 몇 번 반복했는지에 관한 횟수이다. 따라서 반드시 정수이다.

아무리 `l`을 `i` 번 반복하여 돌아도 결국 `l`로 돌아오게 되어있다. 사이클이기 때문이다. 또한 음수도 의미없다. 반대로 돌아도 결과는 마찬가지이기 때문이다.

따라서 `M + K = l` 이 성립하게 되는 것이다.

